/*!
 * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
 *
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * 
 * See the License for the specific language governing permissions and limitations under the License.
 */

import { get } from '../http/request.js';
import { clone, omit, find } from '../util/object.js';
import { isObject } from '../util/types.js';
import { toQueryString } from '../util/url.js';
import AuthSdkError from '../errors/AuthSdkError.js';
import { addStateToken } from './util.js';
import { getPollFn } from './poll.js';
import { postToTransaction } from './api.js';

class AuthTransaction {
    constructor(sdk, res = null) {
        this.data = undefined;
        this.status = undefined;
        if (res) {
            this.data = res;
            if (this.data.interactionHandle) {
                this.status = res.status;
                return;
            }
            Object.assign(this, flattenEmbedded(sdk, res, res, {}));
            delete this.stateToken;
            if (res.status === 'RECOVERY_CHALLENGE' && !res._links) {
                this.cancel = function () {
                    return Promise.resolve(sdk.tx.createTransaction());
                };
            }
        }
    }
}
function link2fn(sdk, res, obj, link, ref) {
    if (Array.isArray(link)) {
        return function (name, opts) {
            if (!name) {
                throw new AuthSdkError('Must provide a link name');
            }
            var lk = find(link, { name: name });
            if (!lk) {
                throw new AuthSdkError('No link found for that name');
            }
            return link2fn(sdk, res, obj, lk, ref)(opts);
        };
    }
    else if (link.hints &&
        link.hints.allow &&
        link.hints.allow.length === 1) {
        var method = link.hints.allow[0];
        switch (method) {
            case 'GET':
                return function () {
                    return get(sdk, link.href, { withCredentials: true });
                };
            case 'POST':
                return function (opts) {
                    if (ref && ref.isPolling) {
                        ref.isPolling = false;
                    }
                    var data = addStateToken(res, opts);
                    if (res.status === 'MFA_ENROLL' || res.status === 'FACTOR_ENROLL') {
                        Object.assign(data, {
                            factorType: obj.factorType,
                            provider: obj.provider
                        });
                    }
                    var params = {};
                    var autoPush = data.autoPush;
                    if (autoPush !== undefined) {
                        if (typeof autoPush === 'function') {
                            try {
                                params.autoPush = !!autoPush();
                            }
                            catch (e) {
                                return Promise.reject(new AuthSdkError('AutoPush resulted in an error.'));
                            }
                        }
                        else if (autoPush !== null) {
                            params.autoPush = !!autoPush;
                        }
                        data = omit(data, 'autoPush');
                    }
                    var rememberDevice = data.rememberDevice;
                    if (rememberDevice !== undefined) {
                        if (typeof rememberDevice === 'function') {
                            try {
                                params.rememberDevice = !!rememberDevice();
                            }
                            catch (e) {
                                return Promise.reject(new AuthSdkError('RememberDevice resulted in an error.'));
                            }
                        }
                        else if (rememberDevice !== null) {
                            params.rememberDevice = !!rememberDevice;
                        }
                        data = omit(data, 'rememberDevice');
                    }
                    else if (data.profile &&
                        data.profile.updatePhone !== undefined) {
                        if (data.profile.updatePhone) {
                            params.updatePhone = true;
                        }
                        data.profile = omit(data.profile, 'updatePhone');
                    }
                    var href = link.href + toQueryString(params);
                    return postToTransaction(sdk, href, data);
                };
        }
    }
}
function links2fns(sdk, res, obj, ref) {
    var fns = {};
    for (var linkName in obj._links) {
        if (!Object.prototype.hasOwnProperty.call(obj._links, linkName)) {
            continue;
        }
        var link = obj._links[linkName];
        if (linkName === 'next') {
            linkName = link.name;
        }
        if (link.type) {
            fns[linkName] = link;
            continue;
        }
        switch (linkName) {
            case 'poll':
                fns.poll = getPollFn(sdk, res, ref);
                break;
            default:
                var fn = link2fn(sdk, res, obj, link, ref);
                if (fn) {
                    fns[linkName] = fn;
                }
        }
    }
    return fns;
}
function flattenEmbedded(sdk, res, obj, ref) {
    obj = obj || res;
    obj = clone(obj);
    if (Array.isArray(obj)) {
        var objArr = [];
        for (var o = 0, ol = obj.length; o < ol; o++) {
            objArr.push(flattenEmbedded(sdk, res, obj[o], ref));
        }
        return objArr;
    }
    var embedded = obj._embedded || {};
    for (var key in embedded) {
        if (!Object.prototype.hasOwnProperty.call(embedded, key)) {
            continue;
        }
        if (isObject(embedded[key]) || Array.isArray(embedded[key])) {
            embedded[key] = flattenEmbedded(sdk, res, embedded[key], ref);
        }
    }
    var fns = links2fns(sdk, res, obj, ref);
    Object.assign(embedded, fns);
    obj = omit(obj, '_embedded', '_links');
    Object.assign(obj, embedded);
    return obj;
}

export { AuthTransaction };
//# sourceMappingURL=AuthTransaction.js.map
