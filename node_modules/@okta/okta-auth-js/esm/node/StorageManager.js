/*!
 * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
 *
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * 
 * See the License for the specific language governing permissions and limitations under the License.
 */

import { TRANSACTION_STORAGE_NAME, SHARED_TRANSACTION_STORAGE_NAME, ORIGINAL_URI_STORAGE_NAME, IDX_RESPONSE_STORAGE_NAME, TOKEN_STORAGE_NAME, CACHE_STORAGE_NAME, PKCE_STORAGE_NAME, REDIRECT_OAUTH_PARAMS_NAME } from './constants.js';
import SavedObject from './SavedObject.js';
import { isBrowser } from './features.js';
import { warn } from './util/console.js';
import AuthSdkError from './errors/AuthSdkError.js';

function logServerSideMemoryStorageWarning(options) {
    if (!isBrowser() && !options.storageProvider && !options.storageProvider) {
        warn('Memory storage can only support simple single user use case on server side, please provide custom storageProvider or storageKey if advanced scenarios need to be supported.');
    }
}
class StorageManager {
    constructor(storageManagerOptions, cookieOptions, storageUtil) {
        this.storageManagerOptions = storageManagerOptions;
        this.cookieOptions = cookieOptions;
        this.storageUtil = storageUtil;
    }
    getOptionsForSection(sectionName, overrideOptions) {
        return Object.assign({}, this.storageManagerOptions[sectionName], overrideOptions);
    }
    getStorage(options) {
        options = Object.assign({}, this.cookieOptions, options);
        if (options.storageProvider) {
            return options.storageProvider;
        }
        let { storageType, storageTypes } = options;
        if (storageType === 'sessionStorage') {
            options.sessionCookie = true;
        }
        if (storageType && storageTypes) {
            const idx = storageTypes.indexOf(storageType);
            if (idx >= 0) {
                storageTypes = storageTypes.slice(idx);
                storageType = undefined;
            }
        }
        if (!storageType) {
            storageType = this.storageUtil.findStorageType(storageTypes);
        }
        return this.storageUtil.getStorageByType(storageType, options);
    }
    getTransactionStorage(options) {
        options = this.getOptionsForSection('transaction', options);
        logServerSideMemoryStorageWarning(options);
        const storage = this.getStorage(options);
        const storageKey = options.storageKey || TRANSACTION_STORAGE_NAME;
        return new SavedObject(storage, storageKey);
    }
    getSharedTansactionStorage(options) {
        options = this.getOptionsForSection('shared-transaction', options);
        logServerSideMemoryStorageWarning(options);
        const storage = this.getStorage(options);
        const storageKey = options.storageKey || SHARED_TRANSACTION_STORAGE_NAME;
        return new SavedObject(storage, storageKey);
    }
    getOriginalUriStorage(options) {
        options = this.getOptionsForSection('original-uri', options);
        logServerSideMemoryStorageWarning(options);
        const storage = this.getStorage(options);
        const storageKey = options.storageKey || ORIGINAL_URI_STORAGE_NAME;
        return new SavedObject(storage, storageKey);
    }
    getIdxResponseStorage(options) {
        let storage;
        if (isBrowser()) {
            try {
                storage = this.storageUtil.getStorageByType('memory', options);
            }
            catch (e) {
                warn('No response storage found, you may want to provide custom implementation for intermediate idx responses to optimize the network traffic');
            }
        }
        else {
            const transactionStorage = this.getTransactionStorage(options);
            if (transactionStorage) {
                storage = {
                    getItem: (key) => {
                        const transaction = transactionStorage.getStorage();
                        if (transaction && transaction[key]) {
                            return transaction[key];
                        }
                        return null;
                    },
                    setItem: (key, val) => {
                        const transaction = transactionStorage.getStorage();
                        if (!transaction) {
                            throw new AuthSdkError('Transaction has been cleared, failed to save idxState');
                        }
                        transaction[key] = val;
                        transactionStorage.setStorage(transaction);
                    },
                    removeItem: (key) => {
                        const transaction = transactionStorage.getStorage();
                        if (!transaction) {
                            return;
                        }
                        delete transaction[key];
                        transactionStorage.setStorage(transaction);
                    }
                };
            }
        }
        if (!storage) {
            return null;
        }
        return new SavedObject(storage, IDX_RESPONSE_STORAGE_NAME);
    }
    getTokenStorage(options) {
        options = this.getOptionsForSection('token', options);
        logServerSideMemoryStorageWarning(options);
        const storage = this.getStorage(options);
        const storageKey = options.storageKey || TOKEN_STORAGE_NAME;
        return new SavedObject(storage, storageKey);
    }
    getHttpCache(options) {
        options = this.getOptionsForSection('cache', options);
        const storage = this.getStorage(options);
        const storageKey = options.storageKey || CACHE_STORAGE_NAME;
        return new SavedObject(storage, storageKey);
    }
    getLegacyPKCEStorage(options) {
        options = this.getOptionsForSection('legacy-pkce', options);
        const storage = this.getStorage(options);
        const storageKey = options.storageKey || PKCE_STORAGE_NAME;
        return new SavedObject(storage, storageKey);
    }
    getLegacyOAuthParamsStorage(options) {
        options = this.getOptionsForSection('legacy-oauth-params', options);
        const storage = this.getStorage(options);
        const storageKey = options.storageKey || REDIRECT_OAUTH_PARAMS_NAME;
        return new SavedObject(storage, storageKey);
    }
}

export { StorageManager };
//# sourceMappingURL=StorageManager.js.map
