{"version":3,"sources":["../../lib/TokenManager.ts"],"names":["DEFAULT_OPTIONS","autoRenew","autoRemove","syncStorage","clearPendingRemoveTokens","storage","undefined","expireEarlySeconds","storageKey","TOKEN_STORAGE_NAME","_storageEventDelay","EVENT_EXPIRED","EVENT_RENEWED","EVENT_ADDED","EVENT_REMOVED","EVENT_ERROR","defaultState","expireTimeouts","renewPromise","TokenManager","constructor","sdk","options","emitter","AuthSdkError","storageOptions","secure","storageProvider","storageType","storageManager","getTokenStorage","useSeparateCookies","clock","SdkClock","create","state","on","bind","off","start","setExpireEventTimeoutAll","stop","clearExpireEventTimeoutAll","getOptions","getExpireTime","token","expireTime","expiresAt","hasExpired","now","emitExpired","key","emit","emitRenewed","freshToken","oldToken","emitAdded","emitRemoved","emitError","error","emitEventsForCrossTabsStorageUpdate","newValue","oldValue","oldTokens","getTokensFromStorageValue","newTokens","forEach","newToken","clearExpireEventTimeout","clearTimeout","Object","prototype","hasOwnProperty","call","setExpireEventTimeout","expireEventWait","Math","max","expireEventTimeout","setTimeout","tokenStorage","getStorage","resetExpireEventTimeoutAll","add","setStorage","getSync","get","getTokensSync","tokens","accessToken","idToken","refreshToken","getTokens","getStorageKeyByType","type","getTokenType","setTokens","accessTokenCb","idTokenCb","refreshTokenCb","handleTokenCallback","handleAdded","handleRenewed","handleRemoved","types","existingTokens","existingToken","remove","removedToken","renewToken","renew","validateToken","e","reject","renewTokens","then","tokenType","catch","err","tokenKey","finally","clear","clearStorage","pendingRemove","value","JSON","parse","updateRefreshToken","REFRESH_TOKEN_STORAGE_KEY","addPendingRemoveFlags"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and limitations under the License.\n *\n */\nimport { removeNils, clone } from './util';\nimport { AuthSdkError } from './errors';\nimport { validateToken  } from './oidc/util';\nimport { isLocalhost, isIE11OrLess } from './features';\nimport SdkClock from './clock';\nimport {\n  EventEmitter,\n  Token, \n  Tokens, \n  TokenType, \n  TokenManagerOptions, \n  isIDToken, \n  isAccessToken,\n  isRefreshToken,\n  StorageOptions,\n  StorageType,\n  OktaAuthInterface,\n  StorageProvider,\n  TokenManagerErrorEventHandler,\n  TokenManagerEventHandler,\n  TokenManagerInterface,\n  RefreshToken,\n  AccessTokenCallback,\n  IDTokenCallback,\n  RefreshTokenCallback\n} from './types';\nimport { REFRESH_TOKEN_STORAGE_KEY, TOKEN_STORAGE_NAME } from './constants';\n\nconst DEFAULT_OPTIONS = {\n  // TODO: remove in next major version - OKTA-473815\n  autoRenew: true,\n  autoRemove: true,\n  syncStorage: true,\n  // --- //\n  clearPendingRemoveTokens: true,\n  storage: undefined, // will use value from storageManager config\n  expireEarlySeconds: 30,\n  storageKey: TOKEN_STORAGE_NAME,\n  _storageEventDelay: 0\n};\nexport const EVENT_EXPIRED = 'expired';\nexport const EVENT_RENEWED = 'renewed';\nexport const EVENT_ADDED = 'added';\nexport const EVENT_REMOVED = 'removed';\nexport const EVENT_ERROR = 'error';\n\ninterface TokenManagerState {\n  expireTimeouts: Record<string, unknown>;\n  renewPromise: Promise<Token | undefined> | null;\n}\nfunction defaultState(): TokenManagerState {\n  return {\n    expireTimeouts: {},\n    renewPromise: null\n  };\n}\nexport class TokenManager implements TokenManagerInterface {\n  private sdk: OktaAuthInterface;\n  private clock: SdkClock;\n  private emitter: EventEmitter;\n  private storage: StorageProvider;\n  private state: TokenManagerState;\n  private options: TokenManagerOptions;\n\n  on: (event: string, handler: TokenManagerErrorEventHandler | TokenManagerEventHandler, context?: object) => void;\n  off: (event: string, handler?: TokenManagerErrorEventHandler | TokenManagerEventHandler) => void;\n\n  // eslint-disable-next-line complexity\n  constructor(sdk: OktaAuthInterface, options: TokenManagerOptions = {}) {\n    this.sdk = sdk;\n    this.emitter = (sdk as any).emitter;\n    if (!this.emitter) {\n      throw new AuthSdkError('Emitter should be initialized before TokenManager');\n    }\n    \n    options = Object.assign({}, DEFAULT_OPTIONS, removeNils(options));\n    if (isIE11OrLess()) {\n      options._storageEventDelay = options._storageEventDelay || 1000;\n    }\n    if (!isLocalhost()) {\n      options.expireEarlySeconds = DEFAULT_OPTIONS.expireEarlySeconds;\n    }\n\n    this.options = options;\n\n    const storageOptions: StorageOptions = removeNils({\n      storageKey: options.storageKey,\n      secure: options.secure,\n    });\n    if (typeof options.storage === 'object') {\n      // A custom storage provider must implement getItem(key) and setItem(key, val)\n      storageOptions.storageProvider = options.storage;\n    } else if (options.storage) {\n      storageOptions.storageType = options.storage as StorageType;\n    }\n\n    this.storage = sdk.storageManager.getTokenStorage({...storageOptions, useSeparateCookies: true});\n    this.clock = SdkClock.create(/* sdk, options */);\n    this.state = defaultState();\n\n    this.on = this.emitter.on.bind(this.emitter);\n    this.off = this.emitter.off.bind(this.emitter);\n  }\n\n  start() {\n    if (this.options.clearPendingRemoveTokens) {\n      this.clearPendingRemoveTokens();\n    }\n    this.setExpireEventTimeoutAll();\n  }\n  \n  stop() {\n    this.clearExpireEventTimeoutAll();\n  }\n\n  getOptions(): TokenManagerOptions {\n    return clone(this.options);\n  }\n  \n  getExpireTime(token) {\n    const expireEarlySeconds = this.options.expireEarlySeconds || 0;\n    var expireTime = token.expiresAt - expireEarlySeconds;\n    return expireTime;\n  }\n  \n  hasExpired(token) {\n    var expireTime = this.getExpireTime(token);\n    return expireTime <= this.clock.now();\n  }\n  \n  emitExpired(key, token) {\n    this.emitter.emit(EVENT_EXPIRED, key, token);\n  }\n  \n  emitRenewed(key, freshToken, oldToken) {\n    this.emitter.emit(EVENT_RENEWED, key, freshToken, oldToken);\n  }\n  \n  emitAdded(key, token) {\n    this.emitter.emit(EVENT_ADDED, key, token);\n  }\n  \n  emitRemoved(key, token?) {\n    this.emitter.emit(EVENT_REMOVED, key, token);\n  }\n  \n  emitError(error) {\n    this.emitter.emit(EVENT_ERROR, error);\n  }\n  \n  emitEventsForCrossTabsStorageUpdate(newValue, oldValue) {\n    const oldTokens = this.getTokensFromStorageValue(oldValue);\n    const newTokens = this.getTokensFromStorageValue(newValue);\n    Object.keys(newTokens).forEach(key => {\n      const oldToken = oldTokens[key];\n      const newToken = newTokens[key];\n      if (JSON.stringify(oldToken) !== JSON.stringify(newToken)) {\n        this.emitAdded(key, newToken);\n      }\n    });\n    Object.keys(oldTokens).forEach(key => {\n      const oldToken = oldTokens[key];\n      const newToken = newTokens[key];\n      if (!newToken) {\n        this.emitRemoved(key, oldToken);\n      }\n    });\n  }\n  \n  clearExpireEventTimeout(key) {\n    clearTimeout(this.state.expireTimeouts[key] as any);\n    delete this.state.expireTimeouts[key];\n  \n    // Remove the renew promise (if it exists)\n    this.state.renewPromise = null;\n  }\n  \n  clearExpireEventTimeoutAll() {\n    var expireTimeouts = this.state.expireTimeouts;\n    for (var key in expireTimeouts) {\n      if (!Object.prototype.hasOwnProperty.call(expireTimeouts, key)) {\n        continue;\n      }\n      this.clearExpireEventTimeout(key);\n    }\n  }\n  \n  setExpireEventTimeout(key, token) {\n    if (isRefreshToken(token)) {\n      return;\n    }\n\n    var expireTime = this.getExpireTime(token);\n    var expireEventWait = Math.max(expireTime - this.clock.now(), 0) * 1000;\n  \n    // Clear any existing timeout\n    this.clearExpireEventTimeout(key);\n  \n    var expireEventTimeout = setTimeout(() => {\n      this.emitExpired(key, token);\n    }, expireEventWait);\n  \n    // Add a new timeout\n    this.state.expireTimeouts[key] = expireEventTimeout;\n  }\n  \n  setExpireEventTimeoutAll() {\n    var tokenStorage = this.storage.getStorage();\n    for(var key in tokenStorage) {\n      if (!Object.prototype.hasOwnProperty.call(tokenStorage, key)) {\n        continue;\n      }\n      var token = tokenStorage[key];\n      this.setExpireEventTimeout(key, token);\n    }\n  }\n  \n  // reset timeouts to setup autoRenew for tokens from other document context (tabs)\n  resetExpireEventTimeoutAll() {\n    this.clearExpireEventTimeoutAll();\n    this.setExpireEventTimeoutAll();\n  }\n  \n  add(key, token: Token) {\n    var tokenStorage = this.storage.getStorage();\n    validateToken(token);\n    tokenStorage[key] = token;\n    this.storage.setStorage(tokenStorage);\n    this.emitAdded(key, token);\n    this.setExpireEventTimeout(key, token);\n  }\n  \n  getSync(key) {\n    var tokenStorage = this.storage.getStorage();\n    return tokenStorage[key];\n  }\n  \n  async get(key) {\n    return this.getSync(key);\n  }\n  \n  getTokensSync(): Tokens {\n    const tokens = {} as Tokens;\n    const tokenStorage = this.storage.getStorage();\n    Object.keys(tokenStorage).forEach(key => {\n      const token = tokenStorage[key];\n      if (isAccessToken(token)) {\n        tokens.accessToken = token;\n      } else if (isIDToken(token)) {\n        tokens.idToken = token;\n      } else if (isRefreshToken(token)) { \n        tokens.refreshToken = token;\n      }\n    });\n    return tokens;\n  }\n  \n  async getTokens(): Promise<Tokens> {\n    return this.getTokensSync();\n  }\n\n  getStorageKeyByType(type: TokenType): string {\n    const tokenStorage = this.storage.getStorage();\n    const key = Object.keys(tokenStorage).filter(key => {\n      const token = tokenStorage[key];\n      return (isAccessToken(token) && type === 'accessToken') \n        || (isIDToken(token) && type === 'idToken')\n        || (isRefreshToken(token) && type === 'refreshToken');\n    })[0];\n    return key;\n  }\n\n  private getTokenType(token: Token): TokenType {\n    if (isAccessToken(token)) {\n      return 'accessToken';\n    }\n    if (isIDToken(token)) {\n      return 'idToken';\n    }\n    if(isRefreshToken(token)) {\n      return 'refreshToken';\n    }\n    throw new AuthSdkError('Unknown token type');\n  }\n\n  setTokens(\n    tokens: Tokens,\n    // TODO: callbacks can be removed in the next major version OKTA-407224\n    accessTokenCb?: AccessTokenCallback, \n    idTokenCb?: IDTokenCallback,\n    refreshTokenCb?: RefreshTokenCallback\n  ): void {\n    const handleTokenCallback = (key, token) => {\n      const type = this.getTokenType(token);\n      if (type === 'accessToken') {\n        accessTokenCb && accessTokenCb(key, token);\n      } else if (type === 'idToken') {\n        idTokenCb && idTokenCb(key, token);\n      } else if (type === 'refreshToken') {\n        refreshTokenCb && refreshTokenCb(key, token);\n      }\n    };\n    const handleAdded = (key, token) => {\n      this.emitAdded(key, token);\n      this.setExpireEventTimeout(key, token);\n      handleTokenCallback(key, token);\n    };\n    const handleRenewed = (key, token, oldToken) => {\n      this.emitRenewed(key, token, oldToken);\n      this.clearExpireEventTimeout(key);\n      this.setExpireEventTimeout(key, token);\n      handleTokenCallback(key, token);\n    };\n    const handleRemoved = (key, token) => {\n      this.clearExpireEventTimeout(key);\n      this.emitRemoved(key, token);\n      handleTokenCallback(key, token);\n    };\n    \n    const types: TokenType[] = ['idToken', 'accessToken', 'refreshToken'];\n    const existingTokens = this.getTokensSync();\n\n    // valid tokens\n    types.forEach((type) => {\n      const token = tokens[type];\n      if (token) {\n        validateToken(token, type);\n      }\n    });\n  \n    // add token to storage\n    const storage = types.reduce((storage, type) => {\n      const token = tokens[type];\n      if (token) {\n        const storageKey = this.getStorageKeyByType(type) || type;\n        storage[storageKey] = token;\n      }\n      return storage;\n    }, {});\n    this.storage.setStorage(storage);\n  \n    // emit event and start expiration timer\n    types.forEach(type => {\n      const newToken = tokens[type];\n      const existingToken = existingTokens[type];\n      const storageKey = this.getStorageKeyByType(type) || type;\n      if (newToken && existingToken) { // renew\n        // call handleRemoved first, since it clears timers\n        handleRemoved(storageKey, existingToken);\n        handleAdded(storageKey, newToken);\n        handleRenewed(storageKey, newToken, existingToken);\n      } else if (newToken) { // add\n        handleAdded(storageKey, newToken);\n      } else if (existingToken) { //remove\n        handleRemoved(storageKey, existingToken);\n      }\n    });\n  }\n  \n  remove(key) {\n    // Clear any listener for this token\n    this.clearExpireEventTimeout(key);\n  \n    var tokenStorage = this.storage.getStorage();\n    var removedToken = tokenStorage[key];\n    delete tokenStorage[key];\n    this.storage.setStorage(tokenStorage);\n  \n    this.emitRemoved(key, removedToken);\n  }\n  \n  // TODO: this methods is redundant and can be removed in the next major version OKTA-407224\n  async renewToken(token) {\n    return this.sdk.token?.renew(token);\n  }\n  // TODO: this methods is redundant and can be removed in the next major version OKTA-407224\n  validateToken(token: Token) {\n    return validateToken(token);\n  }\n\n  // TODO: renew method should take no param, change in the next major version OKTA-407224\n  renew(key): Promise<Token | undefined> {\n    // Multiple callers may receive the same promise. They will all resolve or reject from the same request.\n    if (this.state.renewPromise) {\n      return this.state.renewPromise;\n    }\n  \n    try {\n      var token = this.getSync(key);\n      if (!token) {\n        throw new AuthSdkError('The tokenManager has no token for the key: ' + key);\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  \n    // Remove existing autoRenew timeout\n    this.clearExpireEventTimeout(key);\n  \n    // A refresh token means a replace instead of renewal\n    // Store the renew promise state, to avoid renewing again\n    this.state.renewPromise = this.sdk.token.renewTokens()\n      .then(tokens => {\n        this.setTokens(tokens);\n\n        // resolve token based on the key\n        const tokenType = this.getTokenType(token);\n        return tokens[tokenType];\n      })\n      .catch(err => {\n        // If renew fails, remove token from storage and emit error\n        this.remove(key);\n        err.tokenKey = key;\n        this.emitError(err);\n        throw err;\n      })\n      .finally(() => {\n        // Remove existing promise key\n        this.state.renewPromise = null;\n      });\n  \n    return this.state.renewPromise;\n  }\n  \n  clear() {\n    this.clearExpireEventTimeoutAll();\n    this.storage.clearStorage();\n  }\n\n  clearPendingRemoveTokens() {\n    const tokens = this.getTokensSync();\n    Object.keys(tokens).forEach(key => {\n      if (tokens[key].pendingRemove) {\n       this.remove(key);\n      }\n    });\n  }\n  \n  getTokensFromStorageValue(value) {\n    let tokens;\n    try {\n      tokens = JSON.parse(value) || {};\n    } catch (e) {\n      tokens = {};\n    }\n    return tokens;\n  }\n\n  updateRefreshToken(token: RefreshToken) {\n    const key = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY;\n\n    // do not emit any event\n    var tokenStorage = this.storage.getStorage();\n    validateToken(token);\n    tokenStorage[key] = token;\n    this.storage.setStorage(tokenStorage);\n  }\n\n  addPendingRemoveFlags() {\n    const tokens = this.getTokensSync();\n    Object.keys(tokens).forEach(key => {\n      tokens[key].pendingRemove = true;\n    });\n    this.setTokens(tokens);\n  }\n  \n}\n"],"file":"TokenManager.js"}