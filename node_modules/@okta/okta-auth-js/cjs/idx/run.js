"use strict";

exports.run = run;

var _interact = require("./interact");

var _introspect = require("./introspect");

var _remediate = require("./remediate");

var _flow = require("./flow");

var _types = require("../types");

var _idxJs = require("./types/idx-js");

var _transactionMeta = require("./transactionMeta");

var _util = require("./util");

/* eslint-disable @typescript-eslint/no-non-null-assertion */

/*!
 * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
 *
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * 
 * See the License for the specific language governing permissions and limitations under the License.
 */

/* eslint-disable max-statements, complexity, max-depth */
function initializeValues(options) {
  // remove known options, everything else is assumed to be a value
  const knownOptions = ['flow', 'remediators', 'actions', 'withCredentials', 'step', 'shouldProceedWithEmailAuthenticator'];
  const values = { ...options
  };
  knownOptions.forEach(option => {
    delete values[option];
  });
  return values;
}

function initializeData(authClient, data) {
  const {
    options
  } = data;
  let {
    flow,
    withCredentials,
    remediators,
    actions
  } = options;
  const status = _types.IdxStatus.PENDING; // certain options can be set by the flow specification

  flow = flow || authClient.idx.getFlow() || 'default';

  if (flow) {
    authClient.idx.setFlow(flow);
    const flowSpec = (0, _flow.getFlowSpecification)(authClient, flow); // Favor option values over flow spec

    withCredentials = typeof withCredentials !== 'undefined' ? withCredentials : flowSpec.withCredentials;
    remediators = remediators || flowSpec.remediators;
    actions = actions || flowSpec.actions;
  }

  return { ...data,
    options: { ...options,
      flow,
      withCredentials,
      remediators,
      actions
    },
    status
  };
}

async function getDataFromIntrospect(authClient, data) {
  const {
    options
  } = data;
  const {
    stateHandle,
    withCredentials,
    version,
    state,
    scopes,
    recoveryToken,
    activationToken
  } = options;
  let idxResponse;
  let meta = (0, _transactionMeta.getSavedTransactionMeta)(authClient, {
    state,
    recoveryToken,
    activationToken
  }); // may be undefined

  if (stateHandle) {
    idxResponse = await (0, _introspect.introspect)(authClient, {
      withCredentials,
      version,
      stateHandle
    });
  } else {
    var _meta;

    let interactionHandle = (_meta = meta) === null || _meta === void 0 ? void 0 : _meta.interactionHandle; // may be undefined

    if (!interactionHandle) {
      // start a new transaction
      authClient.transactionManager.clear();
      const interactResponse = await (0, _interact.interact)(authClient, {
        withCredentials,
        state,
        scopes,
        activationToken,
        recoveryToken
      });
      interactionHandle = interactResponse.interactionHandle;
      meta = interactResponse.meta;
    } // Introspect to get idx response


    idxResponse = await (0, _introspect.introspect)(authClient, {
      withCredentials,
      version,
      interactionHandle
    });
  }

  return { ...data,
    idxResponse,
    meta
  };
}

async function getDataFromRemediate(data) {
  let {
    idxResponse,
    options,
    values
  } = data;
  const {
    autoRemediate,
    remediators,
    actions,
    flow,
    step,
    shouldProceedWithEmailAuthenticator // will be removed in next major version

  } = options;
  const shouldRemediate = autoRemediate !== false && (remediators || actions || step);

  if (!shouldRemediate) {
    return data;
  }

  values = { ...values,
    stateHandle: idxResponse.rawIdxState.stateHandle
  }; // Can we handle the remediations?

  const {
    idxResponse: idxResponseFromRemediation,
    nextStep,
    canceled
  } = await (0, _remediate.remediate)(idxResponse, values, {
    remediators,
    actions,
    flow,
    step,
    shouldProceedWithEmailAuthenticator // will be removed in next major version

  });
  idxResponse = idxResponseFromRemediation;
  return { ...data,
    idxResponse,
    nextStep,
    canceled
  };
}

async function getTokens(authClient, data) {
  let {
    meta,
    idxResponse
  } = data;
  const {
    interactionCode
  } = idxResponse;
  const {
    clientId,
    codeVerifier,
    ignoreSignature,
    redirectUri,
    urls,
    scopes
  } = meta;
  const tokenResponse = await authClient.token.exchangeCodeForTokens({
    interactionCode,
    clientId,
    codeVerifier,
    ignoreSignature,
    redirectUri,
    scopes
  }, urls);
  return tokenResponse.tokens;
}

async function finalizeData(authClient, data) {
  let {
    options,
    idxResponse,
    canceled,
    status
  } = data;
  const {
    exchangeCodeForTokens
  } = options;
  let shouldClearTransaction = false;
  let clearSharedStorage = true;
  let interactionCode;
  let tokens;
  let enabledFeatures;
  let availableSteps;
  let messages;
  let terminal;

  if (idxResponse) {
    enabledFeatures = (0, _util.getEnabledFeatures)(idxResponse);
    availableSteps = (0, _util.getAvailableSteps)(idxResponse);
    messages = (0, _util.getMessagesFromResponse)(idxResponse);
    terminal = (0, _util.isTerminalResponse)(idxResponse);
  }

  if (terminal) {
    status = _types.IdxStatus.TERMINAL;
    shouldClearTransaction = true;
    clearSharedStorage = false;
  } else if (canceled) {
    status = _types.IdxStatus.CANCELED;
    shouldClearTransaction = true;
  } else if (idxResponse !== null && idxResponse !== void 0 && idxResponse.interactionCode) {
    interactionCode = idxResponse.interactionCode;

    if (exchangeCodeForTokens === false) {
      status = _types.IdxStatus.SUCCESS;
      shouldClearTransaction = false;
    } else {
      tokens = await getTokens(authClient, data);
      status = _types.IdxStatus.SUCCESS;
      shouldClearTransaction = true;
    }
  }

  return { ...data,
    status,
    interactionCode,
    tokens,
    shouldClearTransaction,
    clearSharedStorage,
    enabledFeatures,
    availableSteps,
    messages,
    terminal
  };
}

function handleError(err, data) {
  let {
    error,
    status,
    shouldClearTransaction
  } = data; // current version of idx-js will throw/reject IDX responses. Handle these differently than regular errors

  if ((0, _idxJs.isIdxResponse)(err)) {
    error = err;
    status = _types.IdxStatus.FAILURE;
    shouldClearTransaction = true;
  } else {
    // error is not an IDX response, throw it like a regular error
    throw err;
  }

  return { ...data,
    error,
    status,
    shouldClearTransaction
  };
}

async function run(authClient, options = {}) {
  let data = {
    options,
    values: initializeValues(options)
  };
  data = initializeData(authClient, data);

  try {
    data = await getDataFromIntrospect(authClient, data);
    data = await getDataFromRemediate(data);
  } catch (err) {
    data = handleError(err, data);
  }

  data = await finalizeData(authClient, data);
  const {
    idxResponse,
    meta,
    shouldClearTransaction,
    clearSharedStorage,
    status,
    enabledFeatures,
    availableSteps,
    tokens,
    nextStep,
    messages,
    error,
    interactionCode
  } = data;

  if (shouldClearTransaction) {
    authClient.transactionManager.clear({
      clearSharedStorage
    });
  } else {
    // ensures state is saved to sessionStorage
    (0, _transactionMeta.saveTransactionMeta)(authClient, { ...meta
    });

    if (idxResponse) {
      // Save intermediate idx response in storage to reduce introspect call
      const {
        rawIdxState: rawIdxResponse,
        requestDidSucceed
      } = idxResponse;
      authClient.transactionManager.saveIdxResponse({
        rawIdxResponse,
        requestDidSucceed
      });
    }
  } // from idx-js, used by the widget


  const {
    actions,
    context,
    neededToProceed,
    proceed,
    rawIdxState,
    requestDidSucceed
  } = idxResponse || {};
  return {
    status: status,
    ...(meta && {
      meta
    }),
    ...(enabledFeatures && {
      enabledFeatures
    }),
    ...(availableSteps && {
      availableSteps
    }),
    ...(tokens && {
      tokens
    }),
    ...(nextStep && {
      nextStep
    }),
    ...(messages && messages.length && {
      messages
    }),
    ...(error && {
      error
    }),
    interactionCode,
    // if options.exchangeCodeForTokens is false
    // from idx-js
    actions: actions,
    context: context,
    neededToProceed: neededToProceed,
    proceed: proceed,
    rawIdxState: rawIdxState,
    requestDidSucceed
  };
}
//# sourceMappingURL=run.js.map