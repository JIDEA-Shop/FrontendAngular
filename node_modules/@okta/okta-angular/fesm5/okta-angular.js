/*!
 * Copyright (c) 2017-Present, Okta, Inc. and/or its affiliates. All rights reserved.
 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
 *
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and limitations under the License.
 */
import { __awaiter, __generator, __decorate, __param, __metadata } from 'tslib';
import { InjectionToken, Component, Inject, Optional, Injector, Injectable, Input, Directive, TemplateRef, ViewContainerRef, NgModule, VERSION } from '@angular/core';
import { Router, NavigationStart } from '@angular/router';
import { Location } from '@angular/common';
import { OktaAuth, AuthSdkError, toRelativeUrl } from '@okta/okta-auth-js';
import { filter, mergeMap } from 'rxjs/operators';
import { BehaviorSubject } from 'rxjs';
import { compare } from 'compare-versions';

/*
 * Copyright (c) 2017-Present, Okta, Inc. and/or its affiliates. All rights reserved.
 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
 *
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and limitations under the License.
 */
var OKTA_CONFIG = new InjectionToken('okta.config.angular');
var OKTA_AUTH = new InjectionToken('okta.auth');

/*
 * Copyright (c) 2017-Present, Okta, Inc. and/or its affiliates. All rights reserved.
 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
 *
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and limitations under the License.
 */
var OktaCallbackComponent = /** @class */ (function () {
    function OktaCallbackComponent(config, oktaAuth, injector) {
        this.config = config;
        this.oktaAuth = oktaAuth;
        this.injector = injector;
    }
    OktaCallbackComponent.prototype.ngOnInit = function () {
        return __awaiter(this, void 0, void 0, function () {
            var e_1, isInteractionRequiredError, _a, onAuthResume, onAuthRequired, callbackFn;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        // Parse code or tokens from the URL, store tokens in the TokenManager, and redirect back to the originalUri
                        return [4 /*yield*/, this.oktaAuth.handleLoginRedirect()];
                    case 1:
                        // Parse code or tokens from the URL, store tokens in the TokenManager, and redirect back to the originalUri
                        _b.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        e_1 = _b.sent();
                        isInteractionRequiredError = this.oktaAuth.isInteractionRequiredError || this.oktaAuth.idx.isInteractionRequiredError;
                        if (isInteractionRequiredError(e_1) && this.injector) {
                            _a = this.config, onAuthResume = _a.onAuthResume, onAuthRequired = _a.onAuthRequired;
                            callbackFn = onAuthResume || onAuthRequired;
                            if (callbackFn) {
                                callbackFn(this.oktaAuth, this.injector);
                                return [2 /*return*/];
                            }
                        }
                        this.error = e_1.toString();
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    OktaCallbackComponent = __decorate([
        Component({
            template: "<div>{{error}}</div>"
        }),
        __param(0, Inject(OKTA_CONFIG)),
        __param(1, Inject(OKTA_AUTH)),
        __param(2, Optional()),
        __metadata("design:paramtypes", [Object, OktaAuth,
            Injector])
    ], OktaCallbackComponent);
    return OktaCallbackComponent;
}());

/*
 * Copyright (c) 2017-Present, Okta, Inc. and/or its affiliates. All rights reserved.
 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
 *
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and limitations under the License.
 */
var OktaAuthGuard = /** @class */ (function () {
    function OktaAuthGuard(config, oktaAuth, injector) {
        var _this = this;
        this.config = config;
        this.oktaAuth = oktaAuth;
        this.injector = injector;
        this.updateAuthStateListener = function (authState) {
            if (!authState.isAuthenticated) {
                _this.handleLogin(_this.state.url);
            }
        };
        this.onAuthRequired = this.config.onAuthRequired;
        // Unsubscribe updateAuthStateListener when route change
        var router = injector.get(Router);
        router.events.pipe(filter(function (e) { return e instanceof NavigationStart && _this.state && _this.state.url !== e.url; })).subscribe(function () {
            _this.oktaAuth.authStateManager.unsubscribe(_this.updateAuthStateListener);
        });
    }
    OktaAuthGuard.prototype.canLoad = function (route, segments) {
        return __awaiter(this, void 0, void 0, function () {
            var isAuthenticated, originalUri;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.onAuthRequired = route.data && route.data.onAuthRequired || this.onAuthRequired;
                        return [4 /*yield*/, this.oktaAuth.isAuthenticated()];
                    case 1:
                        isAuthenticated = _a.sent();
                        if (isAuthenticated) {
                            return [2 /*return*/, true];
                        }
                        originalUri = segments[0].path;
                        return [4 /*yield*/, this.handleLogin(originalUri)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/, false];
                }
            });
        });
    };
    /**
     * Gateway for protected route. Returns true if there is a valid accessToken,
     * otherwise it will cache the route and start the login flow.
     * @param route
     * @param state
     */
    OktaAuthGuard.prototype.canActivate = function (route, state) {
        return __awaiter(this, void 0, void 0, function () {
            var isAuthenticated;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // Track states for current route
                        this.state = state;
                        this.onAuthRequired = route.data && route.data.onAuthRequired || this.onAuthRequired;
                        // Protect the route after accessing
                        this.oktaAuth.authStateManager.subscribe(this.updateAuthStateListener);
                        return [4 /*yield*/, this.oktaAuth.isAuthenticated()];
                    case 1:
                        isAuthenticated = _a.sent();
                        if (isAuthenticated) {
                            return [2 /*return*/, true];
                        }
                        return [4 /*yield*/, this.handleLogin(state.url)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/, false];
                }
            });
        });
    };
    OktaAuthGuard.prototype.canActivateChild = function (route, state) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.canActivate(route, state)];
            });
        });
    };
    OktaAuthGuard.prototype.handleLogin = function (originalUri) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                // Store the current path
                this.oktaAuth.setOriginalUri(originalUri);
                if (this.onAuthRequired) {
                    this.onAuthRequired(this.oktaAuth, this.injector);
                }
                else {
                    this.oktaAuth.signInWithRedirect();
                }
                return [2 /*return*/];
            });
        });
    };
    OktaAuthGuard = __decorate([
        Injectable(),
        __param(0, Inject(OKTA_CONFIG)),
        __param(1, Inject(OKTA_AUTH)),
        __metadata("design:paramtypes", [Object, OktaAuth,
            Injector])
    ], OktaAuthGuard);
    return OktaAuthGuard;
}());

var defaultAuthState = {
    isAuthenticated: false
};
var OktaAuthStateService = /** @class */ (function () {
    function OktaAuthStateService(oktaAuth) {
        this.oktaAuth = oktaAuth;
        this._authState = new BehaviorSubject(defaultAuthState);
        // only expose readonly property
        this.authState$ = this._authState.asObservable();
        this.updateAuthState = this.updateAuthState.bind(this);
        // set initial authState
        var initialAuthState = this.oktaAuth.authStateManager.getAuthState() || defaultAuthState;
        this._authState.next(initialAuthState);
        // subscribe to future changes
        this.oktaAuth.authStateManager.subscribe(this.updateAuthState);
    }
    OktaAuthStateService.prototype.ngOnDestroy = function () {
        this.oktaAuth.authStateManager.unsubscribe(this.updateAuthState);
    };
    // Observes as true when any group input can match groups from user claims 
    OktaAuthStateService.prototype.hasAnyGroups = function (groups) {
        var _this = this;
        return this.authState$.pipe(mergeMap(function (_a) {
            var isAuthenticated = _a.isAuthenticated, idToken = _a.idToken;
            return __awaiter(_this, void 0, void 0, function () {
                var key, value, userInfo;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // return false when not authenticated or openid is not in scopes
                            if (!isAuthenticated || !idToken) {
                                return [2 /*return*/, false];
                            }
                            // transform inputs to consistent object format
                            if (typeof groups === 'string') {
                                groups = { groups: [groups] };
                            }
                            if (Array.isArray(groups)) {
                                groups = { groups: groups };
                            }
                            key = Object.keys(groups)[0];
                            value = groups[key];
                            // groups or custom claims is available in idToken
                            if (idToken.claims[key]) {
                                return [2 /*return*/, value.some(function (authority) { return idToken.claims[key].includes(authority); })];
                            }
                            return [4 /*yield*/, this.oktaAuth.getUser()];
                        case 1:
                            userInfo = _b.sent();
                            if (!userInfo[key]) {
                                return [2 /*return*/, false];
                            }
                            return [2 /*return*/, value.some(function (authority) { return userInfo[key].includes(authority); })];
                    }
                });
            });
        }));
    };
    OktaAuthStateService.prototype.updateAuthState = function (authState) {
        this._authState.next(authState);
    };
    OktaAuthStateService = __decorate([
        Injectable(),
        __param(0, Inject(OKTA_AUTH)),
        __metadata("design:paramtypes", [OktaAuth])
    ], OktaAuthStateService);
    return OktaAuthStateService;
}());

var OktaHasAnyGroupDirective = /** @class */ (function () {
    function OktaHasAnyGroupDirective(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    templateRef, viewContainer, authStateService) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.authStateService = authStateService;
    }
    Object.defineProperty(OktaHasAnyGroupDirective.prototype, "oktaHasAnyGroup", {
        set: function (groups) {
            var _this = this;
            this.authStateService.hasAnyGroups(groups)
                .subscribe(function (isAuthorized) {
                // don't update UI if no state change
                if (isAuthorized === _this.previousIsAuthorized) {
                    return;
                }
                _this.previousIsAuthorized = isAuthorized;
                _this.viewContainer.clear();
                if (isAuthorized) {
                    _this.viewContainer.createEmbeddedView(_this.templateRef);
                }
            });
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], OktaHasAnyGroupDirective.prototype, "oktaHasAnyGroup", null);
    OktaHasAnyGroupDirective = __decorate([
        Directive({ selector: '[oktaHasAnyGroup]' }),
        __metadata("design:paramtypes", [TemplateRef,
            ViewContainerRef,
            OktaAuthStateService])
    ], OktaHasAnyGroupDirective);
    return OktaHasAnyGroupDirective;
}());

var packageInfo = {
    'name': '@okta/okta-angular',
    'version': '5.2.0',
    'authJSMinSupportedVersion': '5.3.1'
};

/*
 * Copyright (c) 2017-Present, Okta, Inc. and/or its affiliates. All rights reserved.
 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
 *
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and limitations under the License.
 */
function oktaAuthFactory(config) {
    return config.oktaAuth;
}
var OktaAuthModule = /** @class */ (function () {
    function OktaAuthModule(config, location, router) {
        var _this = this;
        var oktaAuth = config.oktaAuth;
        var isAuthJsSupported = oktaAuth._oktaUserAgent && compare(oktaAuth._oktaUserAgent.getVersion(), packageInfo.authJSMinSupportedVersion, '>=');
        if (!isAuthJsSupported) {
            throw new AuthSdkError("Passed in oktaAuth is not compatible with the SDK, minimum supported okta-auth-js version is " + packageInfo.authJSMinSupportedVersion + ".");
        }
        // Add Okta UA
        oktaAuth._oktaUserAgent.addEnvironment(packageInfo.name + "/" + packageInfo.version);
        oktaAuth._oktaUserAgent.addEnvironment("Angular/" + VERSION.full);
        // Provide a default implementation of `restoreOriginalUri`
        if (!oktaAuth.options.restoreOriginalUri && router && location) {
            oktaAuth.options.restoreOriginalUri = function (_, originalUri) { return __awaiter(_this, void 0, void 0, function () {
                var baseUrl, routePath;
                return __generator(this, function (_a) {
                    baseUrl = window.location.origin + location.prepareExternalUrl('');
                    routePath = toRelativeUrl(originalUri || '/', baseUrl);
                    router.navigateByUrl(routePath);
                    return [2 /*return*/];
                });
            }); };
        }
        // Start services
        oktaAuth.start();
    }
    OktaAuthModule = __decorate([
        NgModule({
            declarations: [
                OktaCallbackComponent,
                OktaHasAnyGroupDirective,
            ],
            exports: [
                OktaCallbackComponent,
                OktaHasAnyGroupDirective,
            ],
            providers: [
                OktaAuthGuard,
                OktaAuthStateService,
                {
                    provide: OKTA_AUTH,
                    useFactory: oktaAuthFactory,
                    deps: [OKTA_CONFIG]
                },
            ]
        }),
        __param(0, Inject(OKTA_CONFIG)),
        __param(1, Optional()),
        __param(2, Optional()),
        __metadata("design:paramtypes", [Object, Location,
            Router])
    ], OktaAuthModule);
    return OktaAuthModule;
}());

export { OKTA_AUTH, OKTA_CONFIG, OktaAuthGuard, OktaAuthModule, OktaAuthStateService, OktaCallbackComponent, oktaAuthFactory as ɵa, OktaHasAnyGroupDirective as ɵb };
//# sourceMappingURL=okta-angular.js.map
